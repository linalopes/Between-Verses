<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Between Verses — Selfie Segmentation (ml5)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <!-- ml5.js (1.x) -->
  <script src="https://unpkg.com/ml5@latest/dist/ml5.min.js"></script>
  <style>
    :root{
      --bg:#0b0b0b;
      --fg:#ffffffcc;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:system-ui,Segoe UI,Arial,sans-serif}
    .wrap{display:flex;flex-direction:column;align-items:center;gap:12px;padding:16px}
    h1{margin:8px 0 4px}
    canvas{max-width:90vw;height:auto;border-radius:14px;border:1px solid rgba(255,255,255,.12)}
    button{
      padding:10px 16px;border-radius:10px;border:1px solid rgba(255,255,255,.25);
      background:linear-gradient(180deg,#222,#111);color:#fff;cursor:pointer
    }
    small{opacity:.8;color:var(--fg)}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Selfie Segmentation (ml5)</h1>
    <button id="startBtn">Start</button>
    <small>Tip: click <b>Start</b> and accept the camera dialog. Detection runs only in your browser; no video is sent to the server.</small>
  </div>

  <script>
    // --- Globals ---
    let video;
    let segmentation = null;
    let selfieSeg = null;
    let running = false;
    let modelReady = false;
    let FEATHER_PX = 4;

    function preload() {
      selfieSeg = ml5.bodySegmentation("SelfieSegmentation", { maskType: "person" });
      selfieSeg.ready.then(() => { modelReady = true; });
    }

    function setup() {
      const cnv = createCanvas(640, 480);
      cnv.parent(document.querySelector('.wrap'));
      clear();

      video = createCapture({ video: true, audio: false });
      video.size(640, 480);
      video.hide();

      if (video && video.elt) {
        video.elt.setAttribute('playsinline', '');
        video.elt.setAttribute('muted', '');
        video.elt.playsInline = true;
        video.elt.muted = true;
        video.elt.autoplay = true;
      }

      document.getElementById('startBtn').addEventListener('click', startSegmentation);

      // stop detection when leaving/hiding the tab
      window.addEventListener('pagehide', stopSegmentation);
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) stopSegmentation();
      });
    }

    async function startSegmentation() {
      if (running) return;
      const btn = document.getElementById('startBtn');

      try {
        if (!modelReady) await selfieSeg.ready;
        await video.elt.play();

        if (video.elt.readyState < 2 || video.elt.paused) {
          console.warn('Video is not ready yet. Click Start again after allowing the camera.');
          btn.textContent = 'Start (allow camera)';
          btn.disabled = false;
          return;
        }

        selfieSeg.detectStart(video, (result) => {
          segmentation = result || null;
        });

        running = true;
        btn.textContent = 'Running…';
        btn.disabled = true;

      } catch (e) {
        console.error(e);
        btn.textContent = 'Start';
        btn.disabled = false;
      }
    }

    function stopSegmentation() {
      if (selfieSeg && running && typeof selfieSeg.detectStop === 'function') {
        selfieSeg.detectStop();
      }
      running = false;
      const btn = document.getElementById('startBtn');
      if (btn) {
        btn.textContent = 'Start';
        btn.disabled = false;
      }
    }

    function draw() {
      background(0);

      if (segmentation && segmentation.mask) {
        // try context filters; if not supported, fallback to drawing without filter
        const ctx = drawingContext;
        const hasFilter = typeof ctx.filter === 'string' || typeof ctx.filter === 'object';

        if (hasFilter) {
          ctx.filter = `invert(1) grayscale(1) contrast(500%) brightness(120%) blur(${FEATHER_PX}px)`;
          image(segmentation.mask, 0, 0, width, height);
          ctx.filter = 'none';
        } else {
          // fallback: draws "raw" mask; still works
          image(segmentation.mask, 0, 0, width, height);
        }
      }
    }
  </script>

</body>
</html>
